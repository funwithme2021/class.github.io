<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8"/>
  <title>539 é«˜åº¦å„ªåŒ–ç‰ˆ (GA + å›æ¸¬ + å¤šé‡å›æ­¸/å€åŸŸåˆ†æ)</title>
  <style>
    body {
  margin: 0;
  padding: 0;
  font-family: "Microsoft JhengHei", sans-serif;
  background: #f4f4f4;
  color: #333;
  
}

/* ä¸»å®¹å™¨ */
.container { margin:1rem; }

/* æ¨™é¡Œ */
h1 {
  text-align: center;
  color: #2c3e50;
  font-size: 1.8rem;
  font-weight: bold;
  margin-bottom: 1rem;
}

h2 {
  color: #34495e;
  font-size: 1.4rem;
  margin-bottom: 0.5rem;
}

/* å¡ç‰‡å€å¡Š */
.card {
  background: #fff;
  padding: 1.2rem;
  border-radius: 10px;
  margin-bottom: 1rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
}

/* æŒ‰éˆ•è¨­è¨ˆ */
.btn {
  background: linear-gradient(to right, #3a6073, #3fada8);
  color: #fff;
  border: none;
  padding: 0.7rem 1.4rem;
  border-radius: 6px;
  cursor: pointer;
  margin: 0.3rem;
  font-size: 1rem;
  transition: all 0.2s ease-in-out;
}

.btn:hover {
  background: linear-gradient(to right, #3fada8, #3a6073);
  transform: scale(1.05);
}

.delete-btn {
  background: #d9534f !important;
}

/* çƒæ¨£å¼ */
#numberGrid {
  display: grid;
  grid-template-columns: repeat(10, 1fr);
  gap: 0.5rem;
  width: 100%;
  max-width: 420px;
  margin: auto;
}

.ball {
  width: 42px;
  height: 42px;
  border-radius: 50%;
  background: #e0e0e0;
  color: #333;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-weight: bold;
  font-size: 1rem;
  transition: all 0.2s;
  user-select: none;
}

.ball:hover {
  background: #ffa726;
  color: white;
}

.ball.selected {
  background: linear-gradient(135deg, #ff9800, #f57c00);
  color: white;
  box-shadow: 0 0 8px rgba(255, 152, 0, 0.8);
  transform: scale(1.1);
}

/* è¡¨æ ¼æ¨£å¼ */
table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 1rem;
}

th, td {
  padding: 0.6rem;
  text-align: center;
  border: 1px solid #ddd;
  font-size: 0.95rem;
}

th {
  background: #3fada8;
  color: white;
}

td {
  background: #fff;
}

/* å‘½ä¸­èˆ‡ä¸­çé¡¯ç¤º */
.hit {
  background: #c8e6c9;
}

.matched {
  background: #ffd54f;
}

/* æ¨™ç±¤æ¨£å¼ */
.badge {
  display: inline-block;
  padding: 0.4rem 0.6rem;
  margin: 3px;
  border-radius: 6px;
  color: white;
  font-size: 0.85rem;
  background: #d9534f;
}

.badge.odd {
  background: #5bc0de;
}

.badge.even {
  background: #5cb85c;
}
/* å‘½ä¸­è™Ÿç¢¼ç‰¹æ®Šæ¨™è¨˜ (åŠ ç²— & ç´…è‰²å¤–æ¡†) */
.highlighted-hit {
  border: 2px solid red;
  font-weight: bold;
  padding: 0.4rem;
  background: #ffeb3b !important; /* è®“å‘½ä¸­è™Ÿç¢¼æ›´æ˜é¡¯ */
  color: black !important;
}

/* âœ… å®Œå…¨å‘½ä¸­çš„è™Ÿç¢¼ */
.matched {
  background: #ffeb3b;
  border: 2px solid red;
  font-weight: bold;
  color: black !important;
}



.hit {
  background: #ffeb3b;
  border: 2px solid red;
  font-weight: bold;
  color: black !important;
}

  </style>
</head>
<body>
    <div class="container">
        <h1>539 é«˜åº¦å„ªåŒ–ç‰ˆ (GA + å›æ¸¬ + å¤šé‡å›æ­¸/å€åŸŸåˆ†æ)</h1>
      
        <!-- (A) æ–°å¢/åŒ¯å…¥æ­·å²ç´€éŒ„ -->
        <div class="card">
          <h2>é¸ 5 è™Ÿï¼Œæ–°å¢ã€Œ539ã€é–‹çç´€éŒ„</h2>
          <div id="numberGrid"></div>
          <button class="btn" id="addDrawBtn">æ–°å¢é–‹çç´€éŒ„</button>
          <button class="btn" id="exportBtn">åŒ¯å‡º</button>
          <input type="file" id="importFile" style="display:none" accept=".json"/>
          <button class="btn" id="importBtn">åŒ¯å…¥</button>
        </div>
      
        <!-- (C) åˆ†æèˆ‡é æ¸¬ -->
        <div class="card">
          <h2>åˆ†æèˆ‡é æ¸¬</h2>
          <button class="btn" id="analyzeBtn">é–‹å§‹åˆ†æä¸¦é æ¸¬</button>
          <div id="analysisOutput"></div>
        </div>
      
        <!-- (D) æ­·å²ç´€éŒ„åˆ†å¸ƒè¡¨ -->
        <div class="card">
          <h2>æ­·å²ç´€éŒ„åˆ†å¸ƒè¡¨</h2>
          <table>
            <thead id="distTableHead"></thead>
            <tbody id="distTableBody"></tbody>
          </table>
        </div>
      </div>
      <div id="analysisStatus" style="font-size:1.2rem; color:#888; margin-bottom:1rem;"></div>
<div id="analysisOutput"></div>


<script>
/* =====================================
   å…¨åŸŸè³‡æ–™èˆ‡åƒæ•¸è¨­å®š
===================================== */
// æ­·å²ç´€éŒ„ï¼Œæ¯ç­†æ ¼å¼ï¼š { index, nums:[äº”å€‹è™Ÿç¢¼] }
let draws = [];
// é æ¸¬ç´€éŒ„ï¼Œå­˜æ”¾æ¯æ¬¡é æ¸¬çµæœ
let predictionHistory = [];

/* å‹•æ…‹æ¬Šé‡åƒæ•¸ï¼ˆå¯ç”±å›æ¸¬èª¿æ•´ï¼‰ */
let WEIGHT = {
  freqWeight: 5,
  extremePenalty: 2,
  missing10Bonus: 3,
  missing5Bonus: 1,
  consecutive2Penalty: 2,
  consecutive3Penalty: 9999,
  oddEvenBonus: 1,
  pairHighThreshold: 0.2,
  pairBonus: 1,
  appearNextThreshold: 0.3,
  appearNextBonus: 1,
  tripleCountThreshold: 4,
  tripleBonus: 2,
  quadBonus: 0.5,         // å››è™Ÿçµ„åˆåŠ åˆ†
  comparePatternBonus: 1,
  sumOutOfRangePenalty: 50,
  tooManyAdjPenalty: 5,
  unbalancedOddEvenPenalty: 10,
  maxConsecutivePenalty: 5, // æ¯è¶…å‡ºæœ€å¤§é€£è™Ÿé•·åº¦æ‰£åˆ†
  regionBonus: 1          // å€åŸŸç†±é–€åŠ åˆ†
};

/* GA åƒæ•¸ï¼ˆå°‡æ ¹æ“šå›æ¸¬çµæœè‡ªå‹•èª¿æ•´ï¼Œæ­¤è™•ç¤ºç¯„å›ºå®šæ•¸å€¼ï¼Œå¯ä¾å¯¦æ¸¬å‹•æ…‹èª¿æ•´ï¼‰ */
let GA_PARAMS = { popSize: 200, generations: 50, elitismRate: 0.05 };
function someFunction() {
  console.log(GA_PARAMS.popSize); // æ­£å¸¸ä½¿ç”¨
}
function dynamicAdjustGAParams(currentScore, previousBestScore, elapsedTime, currentGeneration, totalGenerations) {
  // èª¿æ•´æ—ç¾¤å¤§å°å’Œä»£æ•¸
  if (currentScore > previousBestScore) {
    GA_PARAMS.popSize = Math.max(100, GA_PARAMS.popSize - 50);
    GA_PARAMS.generations = Math.max(20, GA_PARAMS.generations - 10);
  } else {
    GA_PARAMS.popSize = Math.min(500, GA_PARAMS.popSize + 50);
    GA_PARAMS.generations = Math.min(100, GA_PARAMS.generations + 10);
  }

  // èª¿æ•´èè‹±æ¯”ä¾‹
  if (currentScore > 0.8 * previousBestScore) {
    GA_PARAMS.elitismRate = Math.min(0.1, GA_PARAMS.elitismRate + 0.01);
  } else {
    GA_PARAMS.elitismRate = Math.max(0.03, GA_PARAMS.elitismRate - 0.01);
  }


  // ä»£æ•¸å¾ŒæœŸèª¿æ•´
  if (currentGeneration > totalGenerations * 0.5) {
    GA_PARAMS.popSize = Math.max(100, GA_PARAMS.popSize - 10);
  }

  console.log(`ğŸ”§ èª¿æ•´å¾Œåƒæ•¸: popSize=${GA_PARAMS.popSize}, generations=${GA_PARAMS.generations}, elitismRate=${GA_PARAMS.elitismRate}`);
}

/* =====================================
   å›ºå®šç¨®å­äº‚æ•¸ï¼ˆç¢ºä¿çµæœç©©å®šï¼‰
   ä½¿ç”¨ç°¡å–®ç·šæ€§åŒé¤˜æ³•ï¼ˆLCGï¼‰
===================================== */
// âœ… **å›ºå®šç¨®å­ï¼Œç¢ºä¿æ¯æ¬¡åŸ·è¡Œçµæœä¸€è‡´**
let seed = 123456789;
function seededRandom() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}
function randomChoice(arr) {
  return arr[Math.floor(seededRandom() * arr.length)];
}
function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(seededRandom() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function genRandomChromosome(pool) {
  let copy = pool.slice();
  shuffle(copy);
  let genes = copy.slice(0, 5).sort((a, b) => a - b);
  return { genes, fitness: 0 };
}


/* =====================================
   ç”¢ç”Ÿ 1~39 è™Ÿçƒ
===================================== */
const numberGrid = document.getElementById("numberGrid");
for (let i = 1; i <= 39; i++) {
  let ball = document.createElement("div");
  ball.classList.add("ball");
  ball.textContent = (i < 10 ? "0" + i : "" + i);
  ball.dataset.num = i;
  ball.addEventListener("click", () => toggleBall(ball));
  numberGrid.appendChild(ball);
}
function toggleBall(ball) {
  if (ball.classList.contains("selected")) {
    ball.classList.remove("selected");
  } else {
    let sel = document.querySelectorAll(".ball.selected");
    if (sel.length >= 5) {
      alert("ä¸€æ¬¡åªèƒ½é¸ 5 å€‹çƒè™Ÿ");
      return;
    }
    ball.classList.add("selected");
  }
}

/* =====================================
   æ–°å¢ & åˆªé™¤æ­·å²ç´€éŒ„
   æ¯æ¬¡æ–°å¢è³‡æ–™å¾Œè‡ªå‹•åŸ·è¡Œå…§éƒ¨å›æ¸¬èˆ‡æ¬Šé‡å„ªåŒ–ï¼ˆä¸é¡¯ç¤ºï¼‰
===================================== */
document.getElementById("addDrawBtn").addEventListener("click", () => {
  let selected = [...document.querySelectorAll(".ball.selected")];
  if (selected.length !== 5) {
    alert("éœ€é¸ 5 å€‹çƒè™Ÿ");
    return;
  }
  let nums = selected.map(b => parseInt(b.dataset.num, 10)).sort((a, b) => a - b);
  draws.push({
    index: draws.length + 1,
    nums
  });
  selected.forEach(b => b.classList.remove("selected"));
  renderDistributionTable();
  // è‡ªå‹•åŸ·è¡Œå…§éƒ¨å›æ¸¬èˆ‡æ¬Šé‡å„ªåŒ–ï¼ˆä¸é¡¯ç¤ºçµæœï¼‰
  internalBacktestAndOptimize();
});

/* =====================================
   æ¸²æŸ“æ­·å²ç´€éŒ„åˆ†å¸ƒè¡¨
===================================== */
const distTableHead = document.getElementById("distTableHead");
const distTableBody = document.getElementById("distTableBody");
function renderDistributionTable() {
  distTableHead.innerHTML = "";
  distTableBody.innerHTML = "";
  if (draws.length === 0) {
    distTableHead.innerHTML = "<tr><th>å°šç„¡è³‡æ–™</th></tr>";
    return;
  }
  let trH = document.createElement("tr");
  trH.innerHTML = "<th>æœŸæ•¸</th>";
  for (let i = 1; i <= 39; i++) {
    let th = document.createElement("th");
    th.textContent = (i < 10 ? "0" + i : "" + i);
    trH.appendChild(th);
  }
  trH.innerHTML += "<th>åˆªé™¤</th>";
  distTableHead.appendChild(trH);

  // è®“æœ€æ–°çš„è³‡æ–™æ’åœ¨æœ€ä¸Šé¢
  draws.slice().reverse().forEach((d, idx) => {
    let tr = document.createElement("tr");
    let tdI = document.createElement("td");
    tdI.textContent = d.index;
    tr.appendChild(tdI);
    let setNums = new Set(d.nums);
    for (let i = 1; i <= 39; i++) {
      let td = document.createElement("td");
      if (setNums.has(i)) {
        td.textContent = (i < 10 ? "0" + i : i);
        td.classList.add("hit");
      } else {
        td.textContent = "";
      }
      tr.appendChild(td);
    }
    let tdDel = document.createElement("td");
    let btn = document.createElement("button");
    btn.classList.add("btn", "delete-btn");
    btn.textContent = "åˆªé™¤";
    btn.addEventListener("click", () => {
      // ç§»é™¤å°æ‡‰çš„ç´¢å¼•å€¼
      let originalIndex = draws.findIndex(draw => draw.index === d.index);
      draws.splice(originalIndex, 1);
      draws.forEach((x, i2) => x.index = i2 + 1);
      renderDistributionTable();
    });
    tdDel.appendChild(btn);
    tr.appendChild(tdDel);
    distTableBody.appendChild(tr);
  });
}


/* =====================================
   åŒ¯å‡º & åŒ¯å…¥
===================================== */
document.getElementById("exportBtn").addEventListener("click", () => {
  if (draws.length === 0) {
    alert("ç„¡è³‡æ–™å¯åŒ¯å‡º");
    return;
  }
  let dataStr = JSON.stringify(draws, null, 2);
  let blob = new Blob([dataStr], { type: "application/json" });
  let url = URL.createObjectURL(blob);
  let a = document.createElement("a");

  // å–å¾—ç•¶å‰æ—¥æœŸ
  let today = new Date();
  let yyyy = today.getFullYear();
  let mm = String(today.getMonth() + 1).padStart(2, '0'); // æœˆä»½è£œ0
  let dd = String(today.getDate()).padStart(2, '0'); // æ—¥æœŸè£œ0
  let formattedDate = `${yyyy}${mm}${dd}`;

  // è¨­å®šä¸‹è¼‰æª”æ¡ˆåç¨±
  a.href = url;
  a.download = `539_draws_${formattedDate}.json`; 
  a.click();
  URL.revokeObjectURL(url);
});

document.getElementById("importBtn").addEventListener("click", () => {
  document.getElementById("importFile").click();
});

document.getElementById("importFile").addEventListener("change", (e) => {
  let file = e.target.files[0];
  if (!file) return;
  let reader = new FileReader();
  reader.onload = (evt) => {
    try {
      let arr = JSON.parse(evt.target.result);
      if (!Array.isArray(arr)) {
        alert("åŒ¯å…¥æ ¼å¼éŒ¯èª¤");
        return;
      }
      draws = arr;
      draws.forEach((x, i) => x.index = i + 1);
      renderDistributionTable();
      alert("åŒ¯å…¥æˆåŠŸ!");
    } catch (err) {
      alert("è§£æ JSON å¤±æ•—:" + err);
    }
  };
  reader.readAsText(file);
  e.target.value = "";
});

/* =====================================
   (B) å…§éƒ¨å›æ¸¬èˆ‡æ¬Šé‡å„ªåŒ–
   æ¯æ¬¡æ–°å¢ä¸€ç­†è³‡æ–™å¾Œè‡ªå‹•å‘¼å«ï¼Œä¸é¡¯ç¤ºçµæœ
   æ­¤è™•ç¤ºç¯„åˆ©ç”¨ç°¡å–®å€™é¸æ—ç¾¤æœç´¢éƒ¨åˆ†æ¬Šé‡ï¼ˆä¾‹å¦‚ freqWeight èˆ‡ missing10Bonusï¼‰
===================================== */
async function runOptimization(candidateCount) {
  if (draws.length < 5) return null; // è³‡æ–™å¤ªå°‘ä¸èª¿æ•´

  let weightCandidates = [];
  for (let i = 0; i < candidateCount; i++) {
    weightCandidates.push({
      freqWeight: 3 + seededRandom() * 6, // 3 ~ 9
      missing10Bonus: 1 + seededRandom() * 4 // 1 ~ 5
    });
  }

  let bestScore = -Infinity;
  let bestCandidate = null;

  // ä½¿ç”¨ Promise.all è®“æ¸¬è©¦ä¸¦è¡Œï¼Œæé«˜æ•ˆèƒ½
  const results = await Promise.all(
    weightCandidates.map(async (candidate) => {
      WEIGHT.freqWeight = candidate.freqWeight;
      WEIGHT.missing10Bonus = candidate.missing10Bonus;
      let score = await testAccuracySimple(draws); // æ¸¬è©¦æº–ç¢ºç‡
      return { ...candidate, score };
    })
  );

  for (let candidate of results) {
    if (candidate.score > bestScore) {
      bestScore = candidate.score;
      bestCandidate = candidate;
    }
  }

  return { bestCandidate, bestScore };
}

// **é¸æ“‡æœ€ä½³ CANDIDATE_COUNT**
async function runOptimization(candidateCount) {
  if (draws.length < 5) return null;

  let weightCandidates = [];
  for (let i = 0; i < candidateCount; i++) {
    weightCandidates.push({
      freqWeight: 3 + seededRandom() * 6,
      missing10Bonus: 1 + seededRandom() * 4,
    });
  }

  let bestScore = -Infinity;
  let bestCandidate = null;

  const results = await Promise.all(
    weightCandidates.map(async candidate => {
      WEIGHT.freqWeight = candidate.freqWeight;
      WEIGHT.missing10Bonus = candidate.missing10Bonus;
      const score = testAccuracySimple(draws);
      return { ...candidate, score };
    })
  );

  results.forEach(candidate => {
    if (candidate.score > bestScore) {
      bestScore = candidate.score;
      bestCandidate = candidate;
    }
  });

  return { bestCandidate, bestScore };
}

async function findBestCandidateCount() {
  let bestCandidate = null;
  let bestScore = -Infinity;
  let bestCount = 0;

  for (let count = 40; count <= 60; count += 2) {
    const { bestCandidate: candidate, bestScore: score } = (await runOptimization(count)) || {};
    if (candidate && score > bestScore) {
      bestScore = score;
      bestCandidate = candidate;
      bestCount = count;
    }
    console.log(`CANDIDATE_COUNT = ${count}, Best Score = ${score}`);
  }

  if (bestCandidate) {
    WEIGHT.freqWeight = bestCandidate.freqWeight;
    WEIGHT.missing10Bonus = bestCandidate.missing10Bonus;
    console.log(`æœ€ä½³åƒæ•¸ï¼šCANDIDATE_COUNT = ${bestCount}, Score = ${bestScore}`);
  } else {
    console.error("æœªæ‰¾åˆ°æœ€ä½³åƒæ•¸");
  }
}

function internalBacktestAndOptimize() {
  findBestCandidateCount();
}


function testAccuracySimple(data) {
  let N = 10;
  if (data.length < N) N = data.length;
  let startIndex = data.length - N;
  let totalHits = 0;
  for (let i = startIndex; i < data.length; i++) {
    if (i === data.length - 1) break;
    let subset = data.slice(0, i + 1);
    let sScores = calcNumberScores(subset);
    doRegressionAnalysis(subset, sScores);
    doQuantumProbability(subset, sScores);
    let arr = [];
    for (let n = 1; n <= 39; n++) {
      if (sScores[n] > -9999) arr.push({ num: n, sc: sScores[n] });
    }
    arr.sort((a, b) => b.sc - a.sc);
    let picked = arr.slice(0, 5).map(x => x.num);
    if (data[i + 1]) {
      let realSet = new Set(data[i + 1].nums);
      picked.forEach(n => {
        if (realSet.has(n)) totalHits++;
      });
    }
  }
  return totalHits;
}

/* =====================================
   (C) åˆ†æèˆ‡é æ¸¬
   ç³»çµ±è‡ªå‹•æ ¹æ“šå…§éƒ¨èª¿æ•´å¾Œçš„æ¬Šé‡é€²è¡Œé æ¸¬
===================================== */
async function findBestRange() {
  let bestRange = 50;
  let bestScore = -Infinity;
  let testedRanges = [];

  console.log("ğŸš€ æ¸¬è©¦ä¸åŒæ“·å–ç¯„åœä¸­...");

  for (let range = 1; range <= 290; range += 1) {  // æ¸¬è©¦ 50~100ï¼Œæ¯æ¬¡å¢åŠ  10
    let startIndex = Math.max(0, draws.length - range);
    let recentData = draws.slice(startIndex);

    let score = await testAccuracySimple(recentData); // æ¸¬è©¦æº–ç¢ºç‡

    console.log(`æ“·å–ç¯„åœ: ${range}ï¼Œæ¸¬è©¦æº–ç¢ºç‡: ${score}`);
    testedRanges.push({ range, score });

    if (score > bestScore) {
      bestScore = score;
      bestRange = range;
    }
  }

  console.log(`âœ… æœ€ä½³ç¯„åœ: ${bestRange}ï¼Œæœ€ä½³æº–ç¢ºç‡: ${bestScore}`);
  return bestRange;
}

// **åŸ·è¡Œåˆ†æ**
document.getElementById("analyzeBtn").addEventListener("click", async () => {
  if (draws.length < 5) {
    alert("è³‡æ–™ä¸è¶³(è‡³å°‘ 5 ç­†)");
    return;
  }

  // **ç­‰å¾… findBestRange() æ‰¾å‡ºæœ€ä½³ç¯„åœ**
  let bestRange = await findBestRange();

  // **ç¢ºä¿ startIndex å·²ç¶“å®šç¾©**
  let startIndex = Math.max(0, draws.length - bestRange);
  let recentData = draws.slice(startIndex);
  
  console.log(`ğŸ”„ ä¾æ“šæ¸¬è©¦çµæœï¼Œé¸æ“‡ç¯„åœ ${bestRange} ä¾†æ“·å–æ•¸æ“š`);
  
  // **å¾ŒçºŒé€²è¡Œæ•¸æ“šåˆ†æ**
  let sScores = calcNumberScores(recentData);
  doRegressionAnalysis(recentData, sScores);
  doQuantumProbability(recentData, sScores);
  comparePatterns(draws.slice(0, 50), recentData, sScores);
  doRegionalTailAnalysis(recentData, sScores);

  let singleArr = [];
  for (let n = 1; n <= 39; n++) {
    if (sScores[n] > -9999) {
      singleArr.push({ num: n, sc: sScores[n] });
    }
  }
  singleArr.sort((a, b) => b.sc - a.sc);
  let top10Numbers = singleArr.slice(0, 10).map(x => x.num);

  let bestSets = generateCandidatesByGA(sScores, {
    avoidAdjacent: true,
    sumRange: [60, 130],
    oddEvenBalance: true,
    maxConsecutiveLen: 2,
    popSize: GA_PARAMS.popSize,
    generations: GA_PARAMS.generations
  });

  let top3 = bestSets.slice(0, 3);
  let tailNums = calcPossibleTails(recentData);

  let nextIndex = draws.length + 1;
  predictionHistory.push({
    drawIndex: nextIndex,
    bestSets: top3,
    tailNums: tailNums,
    top10Numbers: top10Numbers
  });

  renderAnalysisOutput(top3, tailNums, top10Numbers, nextIndex);
  renderHitDisplay();
});


// **åŸ·è¡Œåˆ†æ**
document.getElementById("analyzeBtn").addEventListener("click", async () => {
    if (draws.length < 5) {
      alert("è³‡æ–™ä¸è¶³(è‡³å°‘ 5 ç­†)");
      return;
    }
  
    // **ç­‰å¾… findBestRange() æ‰¾å‡ºæœ€ä½³ç¯„åœ**
    let bestRange = await findBestRange();
  
    // **ç¢ºä¿ startIndex å·²ç¶“å®šç¾©**
    let startIndex = Math.max(0, draws.length - bestRange);
    let recentData = draws.slice(startIndex);
    
    console.log(`ğŸ”„ ä¾æ“šæ¸¬è©¦çµæœï¼Œé¸æ“‡ç¯„åœ ${bestRange} ä¾†æ“·å–æ•¸æ“š`);
    
    // **å¾ŒçºŒé€²è¡Œæ•¸æ“šåˆ†æ**
    let sScores = calcNumberScores(recentData);
    doRegressionAnalysis(recentData, sScores);
    doQuantumProbability(recentData, sScores);
    comparePatterns(draws.slice(0, 50), recentData, sScores);
    doRegionalTailAnalysis(recentData, sScores);
  
    let singleArr = [];
    for (let n = 1; n <= 39; n++) {
      if (sScores[n] > -9999) {
        singleArr.push({ num: n, sc: sScores[n] });
      }
    }
    singleArr.sort((a, b) => b.sc - a.sc);
    let top10Numbers = singleArr.slice(0, 10).map(x => x.num);
  
    let bestSets = generateCandidatesByGA(sScores, {
      avoidAdjacent: true,
      sumRange: [60, 130],
      oddEvenBalance: true,
      maxConsecutiveLen: 3,
      popSize: GA_PARAMS.popSize,
      generations: GA_PARAMS.generations
    });
  
    let top3 = bestSets.slice(0, 3);
    let tailNums = calcPossibleTails(recentData);
  
    let nextIndex = draws.length + 1;
    predictionHistory.push({
      drawIndex: nextIndex,
      bestSets: top3,
      tailNums: tailNums,
      top10Numbers: top10Numbers
    });
  
    renderAnalysisOutput(top3, tailNums, top10Numbers, nextIndex);
    renderHitDisplay();
    });
  
    let recentData = draws.slice(startIndex);
    // è¨ˆç®—å–®è™Ÿåˆ†æ•¸
    let sScores = calcNumberScores(recentData);
    // å›æ­¸åˆ†æï¼šä¸€éšé¦¬å¯å¤«ã€pair èˆ‡ triple
    doRegressionAnalysis(recentData, sScores);
    // é‡å­æ¦‚ç‡ï¼šä»¥å››è™Ÿçµ„åˆç¤ºç¯„
    doQuantumProbability(recentData, sScores);
    // èˆ‡æ›´æ—©æœŸè³‡æ–™æ¯”å°
    comparePatterns(draws.slice(0, 50), recentData, sScores);
    // å€åŸŸèˆ‡å°¾æ•¸åˆ†æ
    doRegionalTailAnalysis(recentData, sScores);
    // å¾å–®è™Ÿåˆ†æ•¸ä¸­æŒ‘å‡ºã€Œæœ€é«˜æ©Ÿç‡çš„ 10 å€‹è™Ÿç¢¼ã€ä¾›åƒè€ƒ
    let singleArr = [];
    for (let n = 1; n <= 39; n++) {
      if (sScores[n] > -9999) {
        singleArr.push({ num: n, sc: sScores[n] });
      }
    }
    singleArr.sort((a, b) => b.sc - a.sc);
    let top10Numbers = singleArr.slice(0, 15).map(x => x.num);
    // ç”¨ GA ç”¢ç”Ÿæœ€ä½³ 5 è™Ÿçµ„åˆ
  
  
    let bestSets = generateCandidatesByGA(sScores, {
      avoidAdjacent: true,
      sumRange: [60, 130],
      oddEvenBalance: true,
      maxConsecutiveLen: 2,
      popSize: GA_PARAMS.popSize,
      generations: GA_PARAMS.generations
    });
    // å–å‰ä¸‰çµ„
    let top3 = bestSets.slice(0, 3);
    // å¯èƒ½å°¾æ•¸
    let tailNums = calcPossibleTails(recentData);
    // è¨˜éŒ„é æ¸¬çµæœï¼ˆåŒ…å« top10Numbersï¼‰
    let nextIndex = draws.length + 1;
    predictionHistory.push({
      drawIndex: nextIndex,
      bestSets: top2,
      tailNums: tailNums,
      top10Numbers: top10Numbers
    });
    // é¡¯ç¤ºé æ¸¬çµæœèˆ‡å‘½ä¸­ç‹€æ³
    renderAnalysisOutput(top3, tailNums, top10Numbers, nextIndex);
    renderHitDisplay();
  ;

/* =====================================
   (C1) calcNumberScores() - åŠ æ¬Šè¨ˆç®—
===================================== */
function calcNumberScores(data) {
  let freq = new Array(40).fill(0);
  data.forEach(d => {
    d.nums.forEach(n => freq[n]++);
  });
  let scores = new Array(40).fill(0);
  // åŸºæœ¬ï¼šå‡ºç¾æ¬¡æ•¸ * freqWeight
  for (let n = 1; n <= 39; n++) {
    scores[n] = freq[n] * WEIGHT.freqWeight;
  }
  // éæ¿¾æ¥µç«¯å€¼ï¼šä¾‹å¦‚ 1 èˆ‡ 39
  scores[1] -= WEIGHT.extremePenalty;
  scores[39] -= WEIGHT.extremePenalty;
  // éºæ¼æœŸ
  let missingMap = calcMissingCount(data);
  for (let n = 1; n <= 39; n++) {
    if (missingMap[n] >= 10) {
      scores[n] += WEIGHT.missing10Bonus;
    } else if (missingMap[n] >= 5) {
      scores[n] += WEIGHT.missing5Bonus;
    }
  }
  // é€£èŠ
  let cMap = calcConsecutiveMap(data);
  for (let n = 1; n <= 39; n++) {
    if (cMap[n] >= 3) {
      scores[n] -= WEIGHT.consecutive3Penalty;
    } else if (cMap[n] === 2) {
      scores[n] -= WEIGHT.consecutive2Penalty;
    }
  }
  // å¥‡å¶å¹³è¡¡
  balanceOddEven(data, scores);
  return scores;
}
function calcMissingCount(data) {
  let lastAppear = new Array(40).fill(-1);
  data.forEach((d, idx) => {
    d.nums.forEach(n => lastAppear[n] = idx);
  });
  let len = data.length;
  let missingCount = new Array(40).fill(0);
  for (let n = 1; n <= 39; n++) {
    if (lastAppear[n] < 0) {
      missingCount[n] = len;
    } else {
      missingCount[n] = len - 1 - lastAppear[n];
    }
  }
  return missingCount;
}
function calcConsecutiveMap(data) {
  let map = {};
  for (let n = 1; n <= 39; n++) map[n] = 0;
  if (data.length === 0) return map;
  let lastSet = new Set(data[data.length - 1].nums);
  for (let n = 1; n <= 39; n++) {
    if (lastSet.has(n)) map[n] = 1;
  }
  if (data.length >= 2) {
    let set2 = new Set(data[data.length - 2].nums);
    for (let n = 1; n <= 39; n++) {
      if (map[n] === 1 && set2.has(n)) {
        map[n] = 2;
      }
    }
  }
  if (data.length >= 3) {
    let set3 = new Set(data[data.length - 3].nums);
    for (let n = 1; n <= 39; n++) {
      if (map[n] === 2 && set3.has(n)) {
        map[n] = 3;
      }
    }
  }
  return map;
}
function balanceOddEven(data, scores) {
  let odd = 0, even = 0;
  data.forEach(d => {
    d.nums.forEach(x => {
      if (x % 2 === 0) even++; else odd++;
    });
  });
  if (even > odd) {
    for (let n = 2; n <= 38; n += 2) {
      scores[n] += WEIGHT.oddEvenBonus;
    }
  } else {
    for (let n = 1; n <= 39; n += 2) {
      scores[n] += WEIGHT.oddEvenBonus;
    }
  }
}

/* =====================================
   (C2) å›æ­¸åˆ†æ
===================================== */
function doRegressionAnalysis(data, scores) {
  if (data.length < 5) return;
  let total = data.length;
  // Pair åŒæ™‚å‡ºç¾
  let pairCount = {};
  data.forEach(d => {
    let arr = d.nums;
    for (let i = 0; i < arr.length; i++) {
      for (let j = i + 1; j < arr.length; j++) {
        let key = (arr[i] < arr[j]) ? (arr[i] + "-" + arr[j]) : (arr[j] + "-" + arr[i]);
        pairCount[key] = (pairCount[key] || 0) + 1;
      }
    }
  });
  for (let k in pairCount) {
    let c = pairCount[k];
    let p = c / total;
    if (p > WEIGHT.pairHighThreshold) {
      let [x, y] = k.split("-").map(Number);
      scores[x] += WEIGHT.pairBonus;
      scores[y] += WEIGHT.pairBonus;
    }
  }
  // ä¸€éšé¦¬å¯å¤«ï¼šè‹¥ä¸Šä¸€æœŸå‡ºç¾å‰‡ä¸‹æœŸé‡ç¾
  // è¨ˆç®—æ•´é«”çš„å¹³å‡é‡ç¾ç‡ï¼Œä½œç‚ºæ–°çš„é–€æª»
// è¨ˆç®—ç¸½å‡ºç¾æ¬¡æ•¸ & ä¸‹ä¸€æœŸçš„å‡ºç¾æ¬¡æ•¸
// ä¸€éšé¦¬å¯å¤«ï¼šè‹¥ä¸Šä¸€æœŸå‡ºç¾å‰‡ä¸‹æœŸé‡ç¾
let appearCount = {};
  let appearNextCount = {};
  for (let i = 0; i < total - 1; i++) {
    let setA = new Set(data[i].nums);
    let setB = new Set(data[i + 1].nums);
    setA.forEach(num => {
      appearCount[num] = (appearCount[num] || 0) + 1;
      if (setB.has(num)) {
        appearNextCount[num] = (appearNextCount[num] || 0) + 1;
      }
    });
  }
  for (let n = 1; n <= 39; n++) {
    if (appearCount[n] > 0) {
      let ratio = (appearNextCount[n] || 0) / appearCount[n];
      if (ratio > WEIGHT.appearNextThreshold) {
        scores[n] += WEIGHT.appearNextBonus;
      }
    }
  }


  // ä¸‰è™Ÿçµ„åˆ
  let tripleCount = {};
  data.forEach(d => {
    let arr = d.nums;
    for (let i = 0; i < arr.length - 2; i++) {
      for (let j = i + 1; j < arr.length - 1; j++) {
        for (let k = j + 1; k < arr.length; k++) {
          let arr3 = [arr[i], arr[j], arr[k]].sort((a, b) => a - b);
          let key = arr3.join("-");
          tripleCount[key] = (tripleCount[key] || 0) + 1;
        }
      }
    }
  });
  for (let key in tripleCount) {
    let cnt = tripleCount[key];
    if (cnt >= WEIGHT.tripleCountThreshold) {
      let [x, y, z] = key.split("-").map(Number);
      scores[x] += WEIGHT.tripleBonus;
      scores[y] += WEIGHT.tripleBonus;
      scores[z] += WEIGHT.tripleBonus;
    }
  }
  // å¯å»¶ä¼¸äºŒéšé¦¬å¯å¤«ã€å››è™Ÿçµ„åˆç­‰
}

/* =====================================
   (C3) é‡å­æ¦‚ç‡ï¼šä»¥å››è™Ÿçµ„åˆç¤ºç¯„
===================================== */
function doQuantumProbability(data, scores) {
  let quadCount = {};
  data.forEach(d => {
    let arr = d.nums;
    for (let i = 0; i < arr.length - 3; i++) {
      for (let j = i + 1; j < arr.length - 2; j++) {
        for (let k = j + 1; k < arr.length - 1; k++) {
          for (let m = k + 1; m < arr.length; m++) {
            let arr4 = [arr[i], arr[j], arr[k], arr[m]].sort((a, b) => a - b);
            let key = arr4.join("-");
            quadCount[key] = (quadCount[key] || 0) + 1;
          }
        }
      }
    }
  });
  for (let key in quadCount) {
    let cnt = quadCount[key];
    if (cnt >= 2) {
      let parts = key.split("-").map(Number);
      parts.forEach(n => {
        scores[n] += WEIGHT.quadBonus;
      });
    }
  }
  // æ­¤å¤–å¯è¨ˆç®—ç†µå€¼ç­‰
}

/* =====================================
   (C4) èˆ‡æ›´æ—©æœŸè³‡æ–™æ¯”å°
===================================== */
function comparePatterns(oldData, recentData, scores) {
  let freqOld = new Array(40).fill(0);
  let freqRecent = new Array(40).fill(0);
  oldData.forEach(d => d.nums.forEach(n => freqOld[n]++));
  recentData.forEach(d => d.nums.forEach(n => freqRecent[n]++));
  let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;
  for (let n = 1; n <= 39; n++) {
    let x = freqOld[n], y = freqRecent[n];
    sumXY += x * y;
    sumX += x;
    sumY += y;
    sumX2 += x * x;
    sumY2 += y * y;
  }
  let numerator = (39 * sumXY) - (sumX * sumY);
  let denominator = Math.sqrt(((39 * sumX2) - (sumX * sumX)) * ((39 * sumY2) - (sumY * sumY)));
  let corr = (denominator === 0) ? 0 : (numerator / denominator);
  if (corr > 0.5) {
    for (let n = 1; n <= 39; n++) {
      if (freqOld[n] >= (oldData.length * 0.3)) {
        scores[n] += WEIGHT.comparePatternBonus;
      }
    }
  }
}

/* =====================================
   (C5) å€åŸŸèˆ‡å°¾æ•¸åˆ†æï¼šå°‡ 1ï½39 åˆ†æˆ 4 å€‹å€åŸŸï¼Œä¸¦çµåˆå°¾æ•¸åˆ†æ•£åº¦
===================================== */
function doRegionalTailAnalysis(data, scores) {
  let regions = [
    { start: 1, end: 10, total: 0 },
    { start: 11, end: 20, total: 0 },
    { start: 21, end: 30, total: 0 },
    { start: 31, end: 39, total: 0 }
  ];
  data.forEach(d => {
    d.nums.forEach(n => {
      for (let reg of regions) {
        if (n >= reg.start && n <= reg.end) {
          reg.total++;
          break;
        }
      }
    });
  });
  regions.sort((a, b) => b.total - a.total);
  let bestRegion = regions[0];
  for (let n = bestRegion.start; n <= bestRegion.end; n++) {
    scores[n] += WEIGHT.regionBonus;
  }
  // åŒæ™‚è¨ˆç®—å°¾æ•¸ç†±é–€ç¨‹åº¦ï¼ˆå¯ä½œé€²ä¸€æ­¥åŠ åˆ†è™•ç†ï¼‰
}

/* =====================================
   (C6) å¯èƒ½å°¾æ•¸ï¼šå–å‡ºæœ€ç†±é–€çš„ 3 å€‹å°¾æ•¸
===================================== */
function calcPossibleTails(data) {
  let tailFreq = new Array(10).fill(0);
  data.forEach(d => {
    d.nums.forEach(x => {
      tailFreq[x % 10]++;
    });
  });
  let arr = [];
  for (let t = 0; t < 10; t++) {
    arr.push({ t, f: tailFreq[t] });
  }
  arr.sort((a, b) => b.f - a.f);
  return arr.slice(0, 3).map(o => o.t);
}

/* =====================================
   (C7) GA ç”¢ç”Ÿæœ€ä½³çµ„åˆï¼ˆå¤šé»äº¤é…èˆ‡èè‹±ä¿ç•™ï¼‰
===================================== */
function generateCandidatesByGA(scores, opts) {
  // âœ… è®“ GA åƒæ•¸å‹•æ…‹èª¿æ•´ï¼Œé¿å…è®Šæ•¸æœªå®šç¾©å•é¡Œ
  let GA_PARAMS = {
    popSize: Math.min(500, draws.length * 10), // æ—ç¾¤å¤§å°æ ¹æ“šè³‡æ–™æ•¸é‡è®ŠåŒ–
    generations: Math.min(100, Math.floor(draws.length / 2)), // é€²åŒ–ä»£æ•¸æ ¹æ“šè³‡æ–™æ•¸é‡è®ŠåŒ–
    elitismRate: 0.05 // èè‹±ä¿ç•™
  };

  let pool = [];
  for (let n = 1; n <= 39; n++) {
    if (scores[n] > -9999) pool.push(n);
  }

  // **âœ… æ­£ç¢ºä½¿ç”¨ GA_PARAMS.popSize**
  let population = [];
  for (let i = 0; i < GA_PARAMS.popSize; i++) {
    population.push(genRandomChromosome(pool));
  }

  let eliteCount = Math.floor(GA_PARAMS.popSize * GA_PARAMS.elitismRate);

  // **âœ… ä¿®æ­£ generations è®Šæ•¸**
  for (let g = 0; g < GA_PARAMS.generations; g++) {
    population.forEach(ch => {
      ch.fitness = scoreCandidateSet(ch.genes, scores, opts);
    });

    population.sort((a, b) => b.fitness - a.fitness);
    let elites = population.slice(0, eliteCount);

    let newPop = population.slice(0, Math.floor(GA_PARAMS.popSize / 2));
    while (newPop.length < GA_PARAMS.popSize - eliteCount) {
      let p1 = randomChoice(population.slice(0, Math.floor(GA_PARAMS.popSize / 2)));
      let p2 = randomChoice(population.slice(0, Math.floor(GA_PARAMS.popSize / 2)));
      let child = crossover(p1, p2, pool, scores, opts);
      mutate(child, pool, scores, 0.1);
      child.fitness = scoreCandidateSet(child.genes, scores, opts);
      newPop.push(child);
    }

    population = elites.concat(newPop);
  }

  population.forEach(ch => {
    ch.fitness = scoreCandidateSet(ch.genes, scores, opts);
  });

  population.sort((a, b) => b.fitness - a.fitness);

  let results = [];
  let usedKey = new Set();
  for (let i = 0; i < population.length; i++) {
    let arr = [...population[i].genes].sort((a, b) => a - b);
    let key = arr.join("-");
    if (!usedKey.has(key)) {
      usedKey.add(key);
      results.push(arr);
    }
    if (results.length >= 100) break;
  }
  return results;
}

function genRandomChromosome(pool) {
  let copy = pool.slice();
  shuffle(copy); // âœ… ç¢ºä¿ shuffle å­˜åœ¨
  let genes = copy.slice(0, 5).sort((a, b) => a - b);
  return { genes, fitness: 0 };
}

function crossover(p1, p2, pool, scores, opts) {
  let points = [];
  let count = Math.floor(seededRandom() * 2) + 2; // 2~3å€‹äº¤å‰é»
  for (let i = 0; i < count; i++) {
    points.push(Math.floor(seededRandom() * 5));
  }
  points.sort((a, b) => a - b);
  let childGenes = [];
  let source = p1.genes;
  for (let pos = 0; pos < 5; pos++) {
    if (points.includes(pos)) {
      source = (source === p1.genes) ? p2.genes : p1.genes;
    }
    childGenes.push(source[pos]);
  }
  childGenes = [...new Set(childGenes)];
  while (childGenes.length < 5) {
    shuffle(pool);
    for (let x of pool) {
      if (!childGenes.includes(x)) {
        childGenes.push(x);
        break;
      }
    }
  }
  childGenes.sort((a, b) => a - b);
  return { genes: childGenes, fitness: 0 };
}
function mutate(ch, pool, scores, rate) {
  if (seededRandom() > rate) return;
  let count = Math.floor(seededRandom() * 2) + 1;
  for (let c = 0; c < count; c++) {
    let idx = Math.floor(seededRandom() * ch.genes.length);
    let used = new Set(ch.genes);
    used.delete(ch.genes[idx]);
    shuffle(pool);
    for (let x of pool) {
      if (!used.has(x)) {
        ch.genes[idx] = x;
        used.add(x);
        break;
      }
    }
  }
  ch.genes.sort((a, b) => a - b);
}

/* =====================================
   (C8) çµ„åˆè©•åˆ†ï¼šæª¢æŸ¥ç›¸é„°ã€ç¸½å’Œã€å¥‡å¶å¹³è¡¡ã€æœ€å¤§é€£è™Ÿé•·åº¦ç­‰
===================================== */
function scoreCandidateSet(set5, scores, opts) {
  let sumScore = 0;
  set5.forEach(n => {
    sumScore += scores[n];
  });
  if (opts.avoidAdjacent) {
    let adjCount = 0;
    for (let i = 0; i < set5.length - 1; i++) {
      if (set5[i + 1] === set5[i] + 1) {
        adjCount++;
      }
    }
    if (adjCount > 1) {
      sumScore -= (adjCount * WEIGHT.tooManyAdjPenalty);
    }
  }
  if (opts.sumRange) {
    let s = set5.reduce((a, b) => a + b, 0);
    if (s < opts.sumRange[0] || s > opts.sumRange[1]) {
      sumScore -= WEIGHT.sumOutOfRangePenalty;
    }
  }
  if (opts.oddEvenBalance) {
    let oddCount = set5.filter(x => x % 2 === 1).length;
    let evenCount = 5 - oddCount;
    if (oddCount > 3 || evenCount > 3) {
      sumScore -= WEIGHT.unbalancedOddEvenPenalty;
    }
  }
  if (opts.maxConsecutiveLen) {
    let maxLen = calcMaxConsecutiveLength(set5);
    if (maxLen > opts.maxConsecutiveLen) {
      sumScore -= (maxLen - opts.maxConsecutiveLen) * WEIGHT.maxConsecutivePenalty;
    }
  }
  return sumScore;
}
function calcMaxConsecutiveLength(arr) {
  let maxLen = 1, curLen = 1;
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] === arr[i - 1] + 1) {
      curLen++;
      if (curLen > maxLen) maxLen = curLen;
    } else {
      curLen = 1;
    }
  }
  return maxLen;
}

/* =====================================
   (C9) é æ¸¬çµæœé¡¯ç¤ºï¼š
   åŒ…æ‹¬å‰ 3 çµ„æœ€ä½³çµ„åˆã€å¯èƒ½å°¾æ•¸ã€æœ€é«˜æ©Ÿç‡ 10 å€‹å–®è™Ÿï¼Œ
   ä¸¦é¡¯ç¤ºå‰ä¸€æœŸé æ¸¬ vs. å¯¦éš›ä¸­ç
===================================== */
function renderAnalysisOutput(top3, tailNums, top10Numbers, nextIndex) {
  let out = document.getElementById("analysisOutput");
  out.innerHTML = "";
  let html = `<h3>ç¬¬ ${nextIndex} æœŸ é æ¸¬çµæœ</h3>`;

  // âœ… æ’åº `top3` å…§çš„çµ„åˆ
  top3.forEach((group, i) => {
    let label = ["ç¬¬ä¸€çµ„", "ç¬¬äºŒçµ„", "ç¬¬ä¸‰çµ„"][i] || ("çµ„åˆ" + (i + 1));
    let sortedGroup = [...group].sort((a, b) => a - b);
    html += `<p>${label}ï¼š `;
    sortedGroup.forEach(n => {
      html += `<span class="badge">${(n < 10 ? "0" + n : n)}</span>`;
    });
    html += `</p>`;
  });

  // âœ… æ’åºä¸¦é¡¯ç¤ºã€Œå¯èƒ½å°¾æ•¸ã€
  let sortedTailNums = [...tailNums].sort((a, b) => a - b);
  html += `<p>å¯èƒ½å°¾æ•¸ï¼š`;
  sortedTailNums.forEach(t => {
    html += `<span class="badge predicted-tail">${t}</span>`;
  });
  html += `</p>`;

  // âœ… æ’åºä¸¦é¡¯ç¤ºã€Œæœ€é«˜æ©Ÿç‡ 10 å€‹è™Ÿç¢¼ã€
  let sortedTop10Numbers = [...top10Numbers].sort((a, b) => a - b);
  html += `<p>æœ€é«˜æ©Ÿç‡ 10 å€‹è™Ÿç¢¼ï¼š `;
  sortedTop10Numbers.forEach(n => {
    html += `<span class="badge">${(n < 10 ? "0" + n : n)}</span> `;
  });
  html += `</p>`;

  // é¡¯ç¤ºå‰ä¸€æœŸçš„åˆ†æå’Œå‘½ä¸­æƒ…æ³
  let lastIndex = draws.length;
  if (lastIndex > 1) {
    let ph = predictionHistory.find(x => x.drawIndex === lastIndex);
    if (ph) {
      let realSet = new Set(draws[lastIndex - 1].nums);
      let realTailSet = new Set(draws[lastIndex - 1].nums.map(n => n % 10)); // âœ… é–‹çå°¾æ•¸é›†åˆ
      let matchedTailNums = [];

      html += `<h4>ä¸ŠæœŸ (ç¬¬ ${lastIndex} æœŸ) å¯¦éš›é–‹ç vs. ç¬¬ ${lastIndex - 1} æœŸé æ¸¬</h4>`;

      ph.bestSets.forEach((g, idx) => {
        let label = ["ç¬¬ä¸€çµ„", "ç¬¬äºŒçµ„", "ç¬¬ä¸‰çµ„"][idx] || ("çµ„åˆ" + (idx + 1));
        let matchedNums = [];
        let line = "";

        // âœ… æ’åºé æ¸¬çµ„åˆ
        let sortedG = [...g].sort((a, b) => a - b);
        sortedG.forEach(num => {
          let numTail = num % 10; // å–å¾—å°¾æ•¸
          if (realSet.has(num)) {
            matchedNums.push(num);
            line += `<span class="badge matched highlighted-hit">${(num < 10 ? "0" + num : num)}</span> `;
          } else if (realTailSet.has(numTail)) {
            // âœ… å°¾æ•¸å‘½ä¸­
            line += `<span class="badge tail-hit">${(num < 10 ? "0" + num : num)}</span> `;
          } else {
            line += `<span class="badge">${(num < 10 ? "0" + num : num)}</span> `;
          }
        });

        html += `<p>${label}ï¼š${line} => å‘½ä¸­è™Ÿç¢¼: [${matchedNums.join(", ")}]</p>`;
      });

      // âœ… è¨ˆç®—ã€Œå¯èƒ½å°¾æ•¸ã€å‘½ä¸­æƒ…æ³
      sortedTailNums.forEach(tail => {
        if (realTailSet.has(tail)) {
          matchedTailNums.push(tail);
        }
      });

      // âœ… é¡¯ç¤ºã€Œå¯èƒ½å°¾æ•¸å‘½ä¸­ã€
      html += `<p>å¯èƒ½å°¾æ•¸ï¼š${sortedTailNums.join("")} => å‘½ä¸­è™Ÿç¢¼: [${matchedTailNums.join(", ")}]</p>`;

      // âœ… é¡¯ç¤ºå‰ä¸€æœŸæœ€é«˜æ©Ÿç‡ 10 å€‹è™Ÿç¢¼
      let previousTop10Numbers = ph.top10Numbers || [];
      let matchedPrevTop10Numbers = previousTop10Numbers.filter(n => realSet.has(n));

      html += `<p>å‰ä¸€æœŸæœ€é«˜æ©Ÿç‡ 10 å€‹è™Ÿç¢¼ï¼š `;
      previousTop10Numbers.sort((a, b) => a - b).forEach(n => {
        if (realSet.has(n)) {
          html += `<span class="badge matched">${(n < 10 ? "0" + n : n)}</span> `;
        } else {
          html += `<span class="badge">${(n < 10 ? "0" + n : n)}</span> `;
        }
      });
      html += `=> å‘½ä¸­è™Ÿç¢¼: [${matchedPrevTop10Numbers.join(", ")}]</p>`;

      // âœ… é¡¯ç¤ºå¯¦éš›é–‹ç
      html += `<p>å¯¦éš›é–‹çï¼š `;
      let sortedRealDraws = [...draws[lastIndex - 1].nums].sort((a, b) => a - b);
      sortedRealDraws.forEach(x => {
        html += `<span class="badge hit">${(x < 10 ? "0" + x : x)}</span> `;
      });
      html += `</p>`;
    }
  }
  out.innerHTML = html;
}


/* =====================================
   (E) å‘½ä¸­é¡¯ç¤ºå€ï¼šåˆ—å‡ºæ‰€æœ‰é æ¸¬ç´€éŒ„èˆ‡å¯¦éš›é–‹çå°ç…§
===================================== */
function renderHitDisplay() {
  let div = document.getElementById("hitDisplay");
  div.innerHTML = "";
  let html = "";
  for (let ph of predictionHistory) {
    let realDraw = draws.find(d => d.index === ph.drawIndex);
    if (realDraw) {
      let realSet = new Set(realDraw.nums);
      let matchedLine = "";
      let groupIndex = 1;
      ph.bestSets.forEach(g => {
        let matchedNums = [];
        g.forEach(n => {
          if (realSet.has(n)) matchedNums.push(n);
        });
        matchedLine += `<p>ç¬¬${groupIndex}çµ„: [${g.join(", ")}], å‘½ä¸­ => [${matchedNums.join(", ")}]</p>`;
        groupIndex++;
      });
      html += `<div style="border:1px solid #ccc; margin:0.5rem; padding:0.5rem;">
        <h4>ç¬¬ ${ph.drawIndex} æœŸé æ¸¬ç´€éŒ„</h4>
        ${matchedLine}
        <p>å¯¦éš›é–‹ç => [${realDraw.nums.join(", ")}]</p>
        <p>æœ€é«˜æ©Ÿç‡ 10 å€‹è™Ÿç¢¼ => [${ph.top10Numbers.join(", ")}]</p>
      </div>`;
    }
  }
  div.innerHTML = html || "<p>å°šç„¡é æ¸¬ç´€éŒ„</p>";
}
</script>
</body>
</html>
